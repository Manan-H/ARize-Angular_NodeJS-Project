"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const _utils_1 = require("@ng-toolkit/_utils");
const bugsnag = require("bugsnag");
const interface_1 = require("@angular-devkit/schematics/src/tree/interface");
const test_1 = require("@schematics/angular/utility/test");
const config_1 = require("@schematics/angular/utility/config");
const dependencies_1 = require("@schematics/angular/utility/dependencies");
const ts = require("typescript");
function index(options) {
    const templateSource = schematics_1.apply(schematics_1.url('files'), [
        schematics_1.move('/')
    ]);
    const expressOptions = JSON.parse(JSON.stringify(options));
    delete expressOptions.disableBugsnag;
    delete expressOptions.http;
    bugsnag.register('0b326fddc255310e516875c9874fed91');
    bugsnag.onBeforeNotify((notification) => {
        let metaData = notification.events[0].metaData;
        metaData.subsystem = {
            package: 'universal',
            options: options
        };
    });
    function getSourceRoot(tree) {
        const workspace = config_1.getWorkspace(tree);
        return `/${workspace.projects[options.clientProject].sourceRoot}`;
    }
    function enhanceServerModule() {
        return (tree) => {
            const serverModulePath = `${getSourceRoot(tree)}/${options.appDir}/${options.rootModuleFileName}`;
            _utils_1.addImportStatement(tree, serverModulePath, 'ServerTransferStateModule', '@angular/platform-server');
            _utils_1.addToNgModule(tree, serverModulePath, 'imports', 'ServerTransferStateModule');
            return tree;
        };
    }
    function renameAndEnhanceBrowserModule() {
        return (tree) => {
            const browserModulePath = `${getSourceRoot(tree)}/${options.appDir}/${options.appDir}.browser.module.ts`;
            const modulePath = `${getSourceRoot(tree)}/${options.appDir}/${options.appDir}.module.ts`;
            const mainPath = `${getSourceRoot(tree)}/main.ts`;
            //create browser entry module
            _utils_1.createOrOverwriteFile(tree, browserModulePath, test_1.getFileContent(tree, modulePath).replace('AppModule', 'AppBrowserModule'));
            //change app.module.ts
            _utils_1.addImportStatement(tree, modulePath, 'CommonModule', '@angular/common');
            _utils_1.addToNgModule(tree, modulePath, 'imports', 'CommonModule');
            if (options.http) {
                _utils_1.addImportStatement(tree, modulePath, 'TransferHttpCacheModule', '@nguniversal/common');
                _utils_1.addImportStatement(tree, modulePath, 'HttpClientModule', '@angular/common/http');
                _utils_1.addToNgModule(tree, modulePath, 'imports', 'TransferHttpCacheModule');
                _utils_1.addToNgModule(tree, modulePath, 'imports', 'HttpClientModule');
            }
            //change app.browser.module.ts
            _utils_1.removeFromNgModule(tree, browserModulePath, 'imports', `BrowserModule.withServerTransition({ appId: '${options.appId}' })`);
            _utils_1.removeFromNgModule(tree, browserModulePath, 'declarations');
            _utils_1.addImportStatement(tree, browserModulePath, 'AppModule', './app.module');
            _utils_1.addToNgModule(tree, browserModulePath, 'imports', 'AppModule');
            _utils_1.addImportStatement(tree, browserModulePath, 'BrowserTransferStateModule', '@angular/platform-browser');
            _utils_1.addToNgModule(tree, browserModulePath, 'imports', 'BrowserTransferStateModule');
            //change entry in main.ts
            _utils_1.addImportStatement(tree, mainPath, 'AppBrowserModule', `./${options.appDir}/app.browser.module`);
            _utils_1.createOrOverwriteFile(tree, mainPath, test_1.getFileContent(tree, mainPath).replace('.bootstrapModule(AppModule)', '.bootstrapModule(AppBrowserModule)'));
            return tree;
        };
    }
    function updateWebpackConfig() {
        return tree => {
            const webpackConfig = test_1.getFileContent(tree, `./webpack.server.config.js`);
            _utils_1.createOrOverwriteFile(tree, `./webpack.server.config.js`, webpackConfig.replace('output: {', `output: {\n\tlibraryTarget: 'commonjs2',`));
            return tree;
        };
    }
    function addWrappers() {
        return tree => {
            const modulePath = `${getSourceRoot(tree)}/${options.appDir}/${options.appDir}.module.ts`;
            _utils_1.addImportStatement(tree, modulePath, 'NgtUniversalModule', '@ng-toolkit/universal');
            _utils_1.addToNgModule(tree, modulePath, 'imports', 'NgtUniversalModule');
            // search for 'window' occurences and replace them with injected Window instance
            tree.getDir(getSourceRoot(tree)).visit(visitor => {
                if (visitor.endsWith('.ts')) {
                    let fileContent = test_1.getFileContent(tree, visitor);
                    if (fileContent.match(/class.*{[\s\S]*?((?:[()'"`\s])localStorage)/)) {
                        _utils_1.addDependencyInjection(tree, visitor, 'localStorage', 'any', '@ng-toolkit/universal', 'LOCAL_STORAGE');
                        updateCode(tree, visitor, 'localStorage');
                        fileContent = test_1.getFileContent(tree, visitor);
                    }
                    if (fileContent.match(/class.*{[\s\S]*?((?:[()'"`\s])window)/)) {
                        _utils_1.addDependencyInjection(tree, visitor, 'window', 'Window', '@ng-toolkit/universal', 'WINDOW');
                        updateCode(tree, visitor, 'window');
                    }
                    // if (fileContent.match(/class.*{[\s\S]*?((?:[()'"`\s])document)/)) {
                    //     addDependencyInjection(tree, visitor, 'document', 'Document', '@ng-toolkit/universal', 'NGT_DOCUMENT');
                    //     updateCode(tree, visitor, 'document');
                    // }
                }
            });
            return tree;
        };
    }
    function applyOtherNgToolkitSchematics() {
        return tree => {
            //applying other schematics (if installed)
            const ngToolkitSettings = _utils_1.getNgToolkitInfo(tree);
            ngToolkitSettings.universal = options;
            _utils_1.updateNgToolkitInfo(tree, ngToolkitSettings);
            let externals = [];
            if (ngToolkitSettings.serverless) {
                ngToolkitSettings.serverless.directory = options.directory;
                ngToolkitSettings.serverless.skipInstall = true;
                externals.push(schematics_1.externalSchematic('@ng-toolkit/serverless', 'ng-add', ngToolkitSettings.serverless));
            }
            else if (tree.exists(`${options.directory}/.firebaserc`)) {
                ngToolkitSettings.serverless = {};
                ngToolkitSettings.serverless.directory = options.directory;
                ngToolkitSettings.serverless.skipInstall = true;
                ngToolkitSettings.serverless.provider = 'firebase';
                externals.push(schematics_1.externalSchematic('@ng-toolkit/serverless', 'ng-add', ngToolkitSettings.serverless));
            }
            const workspace = config_1.getWorkspace(tree);
            const projectArchitect = workspace.projects[options.clientProject].architect;
            if (projectArchitect &&
                projectArchitect.build &&
                projectArchitect.build.configurations &&
                projectArchitect.build.configurations.production &&
                projectArchitect.build.configurations.production.serviceWorker != undefined) {
                if (!ngToolkitSettings.pwa) {
                    ngToolkitSettings.pwa = {};
                }
                ngToolkitSettings.pwa.directory = '/';
                ngToolkitSettings.pwa.skipInstall = true;
                externals.push(schematics_1.externalSchematic('@ng-toolkit/pwa', 'ng-add', ngToolkitSettings.pwa));
            }
            if (externals.length > 0) {
                return schematics_1.chain(externals);
                // (tree, context);
            }
            return tree;
        };
    }
    function applyExpressEngine() {
        return tree => {
            let hasUniversalBuild = false;
            const workspace = config_1.getWorkspace(tree);
            const architect = workspace.projects[options.clientProject].architect;
            if (architect) {
                for (let builder in architect) {
                    if (architect[builder].builder === '@angular-devkit/build-angular:server') {
                        hasUniversalBuild = true;
                    }
                }
            }
            if (!hasUniversalBuild) {
                return schematics_1.externalSchematic('@nguniversal/express-engine', 'ng-add', expressOptions);
            }
            else {
                return schematics_1.noop();
            }
        };
    }
    function addPrerender() {
        return tree => {
            // add dependencies
            dependencies_1.addPackageJsonDependency(tree, {
                type: dependencies_1.NodeDependencyType.Default,
                name: 'domino',
                version: '^2.1.3'
            });
            // add scripts
            const pkgPath = '/package.json';
            const buffer = tree.read(pkgPath);
            if (buffer === null) {
                throw new schematics_1.SchematicsException('Could not find package.json');
            }
            const pkg = JSON.parse(buffer.toString());
            pkg.scripts['serve:prerender'] = 'node static.js';
            pkg.scripts['build:prerender'] = 'npm run build:prod && node dist/prerender.js';
            tree.overwrite(pkgPath, JSON.stringify(pkg, null, 2));
            //add entry in webpack configuration
            const webpackConfig = test_1.getFileContent(tree, `./webpack.server.config.js`);
            _utils_1.createOrOverwriteFile(tree, `./webpack.server.config.js`, webpackConfig.replace(`server: './server.ts'`, `server: './server.ts',\n\tprerender: './prerender.ts'`));
            return tree;
        };
    }
    let rule = schematics_1.chain([
        (tree) => {
            const packageJsonSource = JSON.parse(test_1.getFileContent(tree, `./package.json`));
            if (packageJsonSource.dependencies['@ng-toolkit/serverless']) {
                tree.delete(`./local.js`);
                tree.delete(`./server.ts`);
                tree.delete(`./webpack.server.config.js`);
            }
            return tree;
        },
        schematics_1.mergeWith(templateSource, interface_1.MergeStrategy.Overwrite),
        applyExpressEngine(),
        (tree) => {
            tree.overwrite(`/local.js`, test_1.getFileContent(tree, `/local.js`).replace(/__distFolder__/g, 'dist/server').replace(/__serverPort__/g, options.serverPort));
            tree.overwrite(`/${options.serverFileName}`, test_1.getFileContent(tree, `/${options.serverFileName}`).replace(/\/\/ Start up the Node server.*/gs, '').replace('const app = express();', 'export const app = express();'));
            const pkgPath = '/package.json';
            const buffer = tree.read(pkgPath);
            if (buffer === null) {
                throw new schematics_1.SchematicsException('Could not find package.json');
            }
            const pkg = JSON.parse(buffer.toString());
            pkg.scripts['server'] = 'node local.js';
            pkg.scripts['build:prod'] = 'npm run build:ssr';
            pkg.scripts['serve:ssr'] = 'node local.js';
            tree.overwrite(pkgPath, JSON.stringify(pkg, null, 2));
            dependencies_1.addPackageJsonDependency(tree, {
                type: dependencies_1.NodeDependencyType.Default,
                name: '@nguniversal/common',
                version: '0.0.0'
            });
            return tree;
        },
        enhanceServerModule(),
        renameAndEnhanceBrowserModule(),
        updateWebpackConfig(),
        addWrappers(),
        applyOtherNgToolkitSchematics(),
        addPrerender()
    ]);
    if (!options.disableBugsnag) {
        return _utils_1.applyAndLog(rule);
    }
    else {
        return rule;
    }
}
exports.default = index;
function findStatements(tree, node, filePath, subject, replacement, toReplace) {
    let fileContent = test_1.getFileContent(tree, filePath);
    node.forEachChild(node => {
        if (ts.isIdentifier(node)) {
            let statement = fileContent.substr(node.pos, node.end - node.pos);
            let index = statement.indexOf(subject);
            if (index >= 0) {
                toReplace.push({ key: replacement, start: node.pos + index, end: node.end });
            }
        }
        else {
            findStatements(tree, node, filePath, subject, replacement, toReplace);
        }
    });
}
function updateCode(tree, filePath, varName) {
    let fileContent = test_1.getFileContent(tree, filePath);
    let sourceFile = ts.createSourceFile('temp.ts', fileContent, ts.ScriptTarget.Latest);
    sourceFile.forEachChild(node => {
        if (ts.isClassDeclaration(node)) {
            let replacementTable = [];
            node.members.forEach(node => {
                if (ts.isMethodDeclaration(node)) {
                    node.body.statements.forEach(statement => {
                        findStatements(tree, statement, filePath, varName, `this.${varName}`, replacementTable);
                    });
                }
            });
            replacementTable.reverse().forEach(element => {
                fileContent = fileContent.substr(0, element.start) + element.key + fileContent.substr(element.end);
            });
            _utils_1.createOrOverwriteFile(tree, filePath, fileContent);
        }
    });
}
//# sourceMappingURL=schematics.js.map